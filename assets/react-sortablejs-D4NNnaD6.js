var B=Object.defineProperty;var J=(a,b,u)=>b in a?B(a,b,{enumerable:!0,configurable:!0,writable:!0,value:u}):a[b]=u;var H=(a,b,u)=>J(a,typeof b!="symbol"?b+"":b,u);import{r as T}from"./sortablejs-DL7tV7-L.js";import{r as V}from"./classnames-DoPdyKWf.js";import{b as W}from"./react-_28KP_89.js";import{r as K}from"./tiny-invariant-VgoBDpCm.js";var O={exports:{}},k;function Q(){return k||(k=1,function(a){var b=T,u=V(),$=W(),C=K;function x(s){return s&&s.__esModule?s.default:s}function f(s,e,t,n){Object.defineProperty(s,e,{get:t,set:n,enumerable:!0,configurable:!0})}function v(s,e){return Object.keys(e).forEach(function(t){t==="default"||t==="__esModule"||s.hasOwnProperty(t)||Object.defineProperty(s,t,{enumerable:!0,get:function(){return e[t]}})}),s}f(a.exports,"Sortable",()=>$882b6d93070905b3$re_export$Sortable),f(a.exports,"Direction",()=>$882b6d93070905b3$re_export$Direction),f(a.exports,"DOMRect",()=>$882b6d93070905b3$re_export$DOMRect),f(a.exports,"GroupOptions",()=>$882b6d93070905b3$re_export$GroupOptions),f(a.exports,"MoveEvent",()=>$882b6d93070905b3$re_export$MoveEvent),f(a.exports,"Options",()=>$882b6d93070905b3$re_export$Options),f(a.exports,"PullResult",()=>$882b6d93070905b3$re_export$PullResult),f(a.exports,"PutResult",()=>$882b6d93070905b3$re_export$PutResult),f(a.exports,"SortableEvent",()=>$882b6d93070905b3$re_export$SortableEvent),f(a.exports,"SortableOptions",()=>$882b6d93070905b3$re_export$SortableOptions),f(a.exports,"Utils",()=>$882b6d93070905b3$re_export$Utils),f(a.exports,"ReactSortable",()=>P);function E(s){s.parentElement!==null&&s.parentElement.removeChild(s)}function A(s,e,t){const n=s.children[t]||null;s.insertBefore(e,n)}function w(s){s.forEach(e=>E(e.element))}function S(s){s.forEach(e=>{A(e.parentElement,e.element,e.oldIndex)})}function I(s,e){const t=D(s),n={parentElement:s.from};let r=[];switch(t){case"normal":r=[{element:s.item,newIndex:s.newIndex,oldIndex:s.oldIndex,parentElement:s.from}];break;case"swap":const i={element:s.item,oldIndex:s.oldIndex,newIndex:s.newIndex,...n},c={element:s.swapItem,oldIndex:s.newIndex,newIndex:s.oldIndex,...n};r=[i,c];break;case"multidrag":r=s.oldIndicies.map((p,h)=>({element:p.multiDragElement,oldIndex:p.index,newIndex:s.newIndicies[h].index,...n}));break}return q(r,e)}function N(s,e){const t=L(s,e);return M(s,t)}function L(s,e){const t=[...e];return s.concat().reverse().forEach(n=>t.splice(n.oldIndex,1)),t}function M(s,e,t,n){const r=[...e];return s.forEach(o=>{const l=n&&t&&n(o.item,t);r.splice(o.newIndex,0,l||o.item)}),r}function D(s){return s.oldIndicies&&s.oldIndicies.length>0?"multidrag":s.swapItem?"swap":"normal"}function q(s,e){return s.map(n=>({...n,item:e[n.oldIndex]})).sort((n,r)=>n.oldIndex-r.oldIndex)}function z(s){const{list:e,setList:t,children:n,tag:r,style:o,className:l,clone:i,onAdd:c,onChange:p,onChoose:h,onClone:R,onEnd:m,onFilter:U,onRemove:g,onSort:_,onStart:y,onUnchoose:j,onUpdate:X,onMove:Y,onSpill:Z,onSelect:ee,onDeselect:te,...G}=s;return G}const d={dragging:null};class P extends $.Component{constructor(e){super(e),this.ref=(0,$.createRef)();const t=[...e.list].map(n=>Object.assign(n,{chosen:!1,selected:!1}));e.setList(t,this.sortable,d),x(C)(!e.plugins,`
Plugins prop is no longer supported.
Instead, mount it with "Sortable.mount(new MultiDrag())"
Please read the updated README.md at https://github.com/SortableJS/react-sortablejs.
      `)}componentDidMount(){if(this.ref.current===null)return;const e=this.makeOptions();x(b).create(this.ref.current,e)}componentDidUpdate(e){e.disabled!==this.props.disabled&&this.sortable&&this.sortable.option("disabled",this.props.disabled)}render(){const{tag:e,style:t,className:n,id:r}=this.props,o={style:t,className:n,id:r},l=!e||e===null?"div":e;return(0,$.createElement)(l,{ref:this.ref,...o},this.getChildren())}getChildren(){const{children:e,dataIdAttr:t,selectedClass:n="sortable-selected",chosenClass:r="sortable-chosen",dragClass:o="sortable-drag",fallbackClass:l="sortable-falback",ghostClass:i="sortable-ghost",swapClass:c="sortable-swap-highlight",filter:p="sortable-filter",list:h}=this.props;if(!e||e==null)return null;const R=t||"data-id";return $.Children.map(e,(m,U)=>{if(m===void 0)return;const g=h[U]||{},{className:_}=m.props,y=typeof p=="string"&&{[p.replace(".","")]:!!g.filtered},j=x(u)(_,{[n]:g.selected,[r]:g.chosen,...y});return(0,$.cloneElement)(m,{[R]:m.key,className:j})})}get sortable(){const e=this.ref.current;if(e===null)return null;const t=Object.keys(e).find(n=>n.includes("Sortable"));return t?e[t]:null}makeOptions(){const e=["onAdd","onChoose","onDeselect","onEnd","onRemove","onSelect","onSpill","onStart","onUnchoose","onUpdate"],t=["onChange","onClone","onFilter","onSort"],n=z(this.props);return e.forEach(o=>n[o]=this.prepareOnHandlerPropAndDOM(o)),t.forEach(o=>n[o]=this.prepareOnHandlerProp(o)),{...n,onMove:(o,l)=>{const{onMove:i}=this.props,c=o.willInsertAfter||-1;if(!i)return c;const p=i(o,l,this.sortable,d);return typeof p>"u"?!1:p}}}prepareOnHandlerPropAndDOM(e){return t=>{this.callOnHandlerProp(t,e),this[e](t)}}prepareOnHandlerProp(e){return t=>{this.callOnHandlerProp(t,e)}}callOnHandlerProp(e,t){const n=this.props[t];n&&n(e,this.sortable,d)}onAdd(e){const{list:t,setList:n,clone:r}=this.props,o=[...d.dragging.props.list],l=I(e,o);w(l);const i=M(l,t,e,r).map(c=>Object.assign(c,{selected:!1}));n(i,this.sortable,d)}onRemove(e){const{list:t,setList:n}=this.props,r=D(e),o=I(e,t);S(o);let l=[...t];if(e.pullMode!=="clone")l=L(o,l);else{let i=o;switch(r){case"multidrag":i=o.map((c,p)=>({...c,element:e.clones[p]}));break;case"normal":i=o.map(c=>({...c,element:e.clone}));break;case"swap":default:x(C)(!0,`mode "${r}" cannot clone. Please remove "props.clone" from <ReactSortable/> when using the "${r}" plugin`)}w(i),o.forEach(c=>{const p=c.oldIndex,h=this.props.clone(c.item,e);l.splice(p,1,h)})}l=l.map(i=>Object.assign(i,{selected:!1})),n(l,this.sortable,d)}onUpdate(e){const{list:t,setList:n}=this.props,r=I(e,t);w(r),S(r);const o=N(r,t);return n(o,this.sortable,d)}onStart(){d.dragging=this}onEnd(){d.dragging=null}onChoose(e){const{list:t,setList:n}=this.props,r=t.map((o,l)=>{let i=o;return l===e.oldIndex&&(i=Object.assign(o,{chosen:!0})),i});n(r,this.sortable,d)}onUnchoose(e){const{list:t,setList:n}=this.props,r=t.map((o,l)=>{let i=o;return l===e.oldIndex&&(i=Object.assign(i,{chosen:!1})),i});n(r,this.sortable,d)}onSpill(e){const{removeOnSpill:t,revertOnSpill:n}=this.props;t&&!n&&E(e.item)}onSelect(e){const{list:t,setList:n}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;if(l===-1){console.log(`"${e.type}" had indice of "${o.index}", which is probably -1 and doesn't usually happen here.`),console.log(e);return}r[l].selected=!0}),n(r,this.sortable,d)}onDeselect(e){const{list:t,setList:n}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;l!==-1&&(r[l].selected=!0)}),n(r,this.sortable,d)}}H(P,"defaultProps",{clone:e=>e});var F={};v(a.exports,F)}(O)),O.exports}var ie=Q();export{ie as d};
