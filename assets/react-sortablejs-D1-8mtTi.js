var T=Object.defineProperty;var B=(a,b,u)=>b in a?T(a,b,{enumerable:!0,configurable:!0,writable:!0,value:u}):a[b]=u;var U=(a,b,u)=>B(a,typeof b!="symbol"?b+"":b,u);import{r as J}from"./sortablejs-DIQSCnG0.js";import{a as V,r as W}from"./classnames-DoPdyKWf.js";import{b as K}from"./react-CagRm3VF.js";var O={exports:{}},Q="Invariant failed";function X(a,b){if(!a)throw new Error(Q)}const Y=Object.freeze(Object.defineProperty({__proto__:null,default:X},Symbol.toStringTag,{value:"Module"})),Z=V(Y);var H;function ee(){return H||(H=1,function(a){var b=J,u=W(),$=K(),S=Z;function x(n){return n&&n.__esModule?n.default:n}function f(n,e,t,s){Object.defineProperty(n,e,{get:t,set:s,enumerable:!0,configurable:!0})}function A(n,e){return Object.keys(e).forEach(function(t){t==="default"||t==="__esModule"||n.hasOwnProperty(t)||Object.defineProperty(n,t,{enumerable:!0,get:function(){return e[t]}})}),n}f(a.exports,"Sortable",()=>$882b6d93070905b3$re_export$Sortable),f(a.exports,"Direction",()=>$882b6d93070905b3$re_export$Direction),f(a.exports,"DOMRect",()=>$882b6d93070905b3$re_export$DOMRect),f(a.exports,"GroupOptions",()=>$882b6d93070905b3$re_export$GroupOptions),f(a.exports,"MoveEvent",()=>$882b6d93070905b3$re_export$MoveEvent),f(a.exports,"Options",()=>$882b6d93070905b3$re_export$Options),f(a.exports,"PullResult",()=>$882b6d93070905b3$re_export$PullResult),f(a.exports,"PutResult",()=>$882b6d93070905b3$re_export$PutResult),f(a.exports,"SortableEvent",()=>$882b6d93070905b3$re_export$SortableEvent),f(a.exports,"SortableOptions",()=>$882b6d93070905b3$re_export$SortableOptions),f(a.exports,"Utils",()=>$882b6d93070905b3$re_export$Utils),f(a.exports,"ReactSortable",()=>P);function E(n){n.parentElement!==null&&n.parentElement.removeChild(n)}function k(n,e,t){const s=n.children[t]||null;n.insertBefore(e,s)}function w(n){n.forEach(e=>E(e.element))}function C(n){n.forEach(e=>{k(e.parentElement,e.element,e.oldIndex)})}function I(n,e){const t=D(n),s={parentElement:n.from};let r=[];switch(t){case"normal":r=[{element:n.item,newIndex:n.newIndex,oldIndex:n.oldIndex,parentElement:n.from}];break;case"swap":const i={element:n.item,oldIndex:n.oldIndex,newIndex:n.newIndex,...s},c={element:n.swapItem,oldIndex:n.newIndex,newIndex:n.oldIndex,...s};r=[i,c];break;case"multidrag":r=n.oldIndicies.map((p,h)=>({element:p.multiDragElement,oldIndex:p.index,newIndex:n.newIndicies[h].index,...s}));break}return q(r,e)}function N(n,e){const t=L(n,e);return M(n,t)}function L(n,e){const t=[...e];return n.concat().reverse().forEach(s=>t.splice(s.oldIndex,1)),t}function M(n,e,t,s){const r=[...e];return n.forEach(o=>{const l=s&&t&&s(o.item,t);r.splice(o.newIndex,0,l||o.item)}),r}function D(n){return n.oldIndicies&&n.oldIndicies.length>0?"multidrag":n.swapItem?"swap":"normal"}function q(n,e){return n.map(s=>({...s,item:e[s.oldIndex]})).sort((s,r)=>s.oldIndex-r.oldIndex)}function z(n){const{list:e,setList:t,children:s,tag:r,style:o,className:l,clone:i,onAdd:c,onChange:p,onChoose:h,onClone:_,onEnd:m,onFilter:y,onRemove:g,onSort:R,onStart:j,onUnchoose:v,onUpdate:te,onMove:ne,onSpill:se,onSelect:oe,onDeselect:re,...G}=n;return G}const d={dragging:null};class P extends $.Component{constructor(e){super(e),this.ref=(0,$.createRef)();const t=[...e.list].map(s=>Object.assign(s,{chosen:!1,selected:!1}));e.setList(t,this.sortable,d),x(S)(!e.plugins,`
Plugins prop is no longer supported.
Instead, mount it with "Sortable.mount(new MultiDrag())"
Please read the updated README.md at https://github.com/SortableJS/react-sortablejs.
      `)}componentDidMount(){if(this.ref.current===null)return;const e=this.makeOptions();x(b).create(this.ref.current,e)}componentDidUpdate(e){e.disabled!==this.props.disabled&&this.sortable&&this.sortable.option("disabled",this.props.disabled)}render(){const{tag:e,style:t,className:s,id:r}=this.props,o={style:t,className:s,id:r},l=!e||e===null?"div":e;return(0,$.createElement)(l,{ref:this.ref,...o},this.getChildren())}getChildren(){const{children:e,dataIdAttr:t,selectedClass:s="sortable-selected",chosenClass:r="sortable-chosen",dragClass:o="sortable-drag",fallbackClass:l="sortable-falback",ghostClass:i="sortable-ghost",swapClass:c="sortable-swap-highlight",filter:p="sortable-filter",list:h}=this.props;if(!e||e==null)return null;const _=t||"data-id";return $.Children.map(e,(m,y)=>{if(m===void 0)return;const g=h[y]||{},{className:R}=m.props,j=typeof p=="string"&&{[p.replace(".","")]:!!g.filtered},v=x(u)(R,{[s]:g.selected,[r]:g.chosen,...j});return(0,$.cloneElement)(m,{[_]:m.key,className:v})})}get sortable(){const e=this.ref.current;if(e===null)return null;const t=Object.keys(e).find(s=>s.includes("Sortable"));return t?e[t]:null}makeOptions(){const e=["onAdd","onChoose","onDeselect","onEnd","onRemove","onSelect","onSpill","onStart","onUnchoose","onUpdate"],t=["onChange","onClone","onFilter","onSort"],s=z(this.props);return e.forEach(o=>s[o]=this.prepareOnHandlerPropAndDOM(o)),t.forEach(o=>s[o]=this.prepareOnHandlerProp(o)),{...s,onMove:(o,l)=>{const{onMove:i}=this.props,c=o.willInsertAfter||-1;if(!i)return c;const p=i(o,l,this.sortable,d);return typeof p>"u"?!1:p}}}prepareOnHandlerPropAndDOM(e){return t=>{this.callOnHandlerProp(t,e),this[e](t)}}prepareOnHandlerProp(e){return t=>{this.callOnHandlerProp(t,e)}}callOnHandlerProp(e,t){const s=this.props[t];s&&s(e,this.sortable,d)}onAdd(e){const{list:t,setList:s,clone:r}=this.props,o=[...d.dragging.props.list],l=I(e,o);w(l);const i=M(l,t,e,r).map(c=>Object.assign(c,{selected:!1}));s(i,this.sortable,d)}onRemove(e){const{list:t,setList:s}=this.props,r=D(e),o=I(e,t);C(o);let l=[...t];if(e.pullMode!=="clone")l=L(o,l);else{let i=o;switch(r){case"multidrag":i=o.map((c,p)=>({...c,element:e.clones[p]}));break;case"normal":i=o.map(c=>({...c,element:e.clone}));break;case"swap":default:x(S)(!0,`mode "${r}" cannot clone. Please remove "props.clone" from <ReactSortable/> when using the "${r}" plugin`)}w(i),o.forEach(c=>{const p=c.oldIndex,h=this.props.clone(c.item,e);l.splice(p,1,h)})}l=l.map(i=>Object.assign(i,{selected:!1})),s(l,this.sortable,d)}onUpdate(e){const{list:t,setList:s}=this.props,r=I(e,t);w(r),C(r);const o=N(r,t);return s(o,this.sortable,d)}onStart(){d.dragging=this}onEnd(){d.dragging=null}onChoose(e){const{list:t,setList:s}=this.props,r=t.map((o,l)=>{let i=o;return l===e.oldIndex&&(i=Object.assign(o,{chosen:!0})),i});s(r,this.sortable,d)}onUnchoose(e){const{list:t,setList:s}=this.props,r=t.map((o,l)=>{let i=o;return l===e.oldIndex&&(i=Object.assign(i,{chosen:!1})),i});s(r,this.sortable,d)}onSpill(e){const{removeOnSpill:t,revertOnSpill:s}=this.props;t&&!s&&E(e.item)}onSelect(e){const{list:t,setList:s}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;if(l===-1){console.log(`"${e.type}" had indice of "${o.index}", which is probably -1 and doesn't usually happen here.`),console.log(e);return}r[l].selected=!0}),s(r,this.sortable,d)}onDeselect(e){const{list:t,setList:s}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;l!==-1&&(r[l].selected=!0)}),s(r,this.sortable,d)}}U(P,"defaultProps",{clone:e=>e});var F={};A(a.exports,F)}(O)),O.exports}var de=ee();export{de as d};
